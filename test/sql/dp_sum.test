# dp_sum: Differentially Private Sum Aggregate
# Tests for the dp_sum() aggregate function that applies DP noise to sum aggregates
#
# API: dp_sum(column, epsilon, lower_bound, upper_bound) -> DOUBLE
# Also supports: dp_sum(column, epsilon) with default bounds [0, 10]
# Also supports: dp_sum(column) with default epsilon=1.0, bounds [0, 10]

# Setup test data
statement ok
CREATE TABLE integers(x INT);

statement ok
INSERT INTO integers VALUES (1),(2),(3),(4);

# Test 1: Basic dp_sum with very high epsilon (near-deterministic)
# With huge epsilon, noise is minimal, sum should be close to actual sum of 10
query I
SELECT (dp_sum(x, 1000000000000.0, 0, 10) BETWEEN 9.999999 AND 10.000001)::INT FROM integers;
----
1

# Test 2: Two-argument form (uses default bounds [0,10])
query I
SELECT (dp_sum(x, 1000000000000.0) BETWEEN 9.999999 AND 10.000001)::INT FROM integers;
----
1

# Test 3: One-argument form (uses default epsilon=1.0, bounds [0,10])
# Result will have more noise, just check it returns a number
query I
SELECT dp_sum(x) IS NOT NULL FROM integers;
----
1

# Test 4: Clamping - negative values clamped to lower bound
statement ok
CREATE TABLE negative_vals(x INT);

statement ok
INSERT INTO negative_vals VALUES (-5),(-10);

# Both values clamped to 0, sum should be ~0
query I
SELECT (dp_sum(x, 1000000000000.0, 0, 10) BETWEEN -0.000001 AND 0.000001)::INT FROM negative_vals;
----
1

# Test 5: Clamping - values above upper bound
statement ok
CREATE TABLE large_vals(x INT);

statement ok
INSERT INTO large_vals VALUES (100),(100);

# Both 100s clamped to 10, sum should be ~20
query I
SELECT (dp_sum(x, 1000000000000.0, 0, 10) BETWEEN 19.999999 AND 20.000001)::INT FROM large_vals;
----
1

# Test 6: Different numeric types
statement ok
CREATE TABLE mixed_types(
    i INTEGER,
    b BIGINT,
    f FLOAT,
    d DOUBLE
);

statement ok
INSERT INTO mixed_types VALUES (5, 5, 5.0, 5.0);

# Test INTEGER
query I
SELECT (dp_sum(i, 1000000000000.0, 0, 10) BETWEEN 4.999 AND 5.001)::INT FROM mixed_types;
----
1

# Test BIGINT
query I
SELECT (dp_sum(b, 1000000000000.0, 0, 10) BETWEEN 4.999 AND 5.001)::INT FROM mixed_types;
----
1

# Test FLOAT
query I
SELECT (dp_sum(f, 1000000000000.0, 0, 10) BETWEEN 4.999 AND 5.001)::INT FROM mixed_types;
----
1

# Test DOUBLE
query I
SELECT (dp_sum(d, 1000000000000.0, 0, 10) BETWEEN 4.999 AND 5.001)::INT FROM mixed_types;
----
1

# Test 7: Empty table
statement ok
CREATE TABLE empty_table(x INT);

query I
SELECT (dp_sum(x, 1.0, 0, 10) BETWEEN -1 AND 1)::INT FROM empty_table;
----
1

# Test 8: NULL handling
statement ok
CREATE TABLE with_nulls(x INT);

statement ok
INSERT INTO with_nulls VALUES (1),(NULL),(2),(NULL),(3);

# NULLs should be ignored, sum of 1+2+3=6
query I
SELECT (dp_sum(x, 1000000000000.0, 0, 10) BETWEEN 5.999 AND 6.001)::INT FROM with_nulls;
----
1

# Test 9: GROUP BY with dp_sum
statement ok
CREATE TABLE departments(dept VARCHAR, salary INT);

statement ok
INSERT INTO departments VALUES
    ('eng', 5),
    ('eng', 5),
    ('sales', 3),
    ('sales', 3);

query II
SELECT dept, (dp_sum(salary, 1000000000000.0, 0, 10) BETWEEN 9.99 AND 10.01 OR dp_sum(salary, 1000000000000.0, 0, 10) BETWEEN 5.99 AND 6.01)::INT
FROM departments
GROUP BY dept
ORDER BY dept;
----
eng	1
sales	1

# Test 10: Error cases

# No arguments
statement error
SELECT dp_sum();

# Negative epsilon
statement error
SELECT dp_sum(1, -1.0);

# Lower bound >= upper bound
statement error
SELECT dp_sum(1, 1.0, 10, 0);

# Lower bound == upper bound
statement error
SELECT dp_sum(1, 1.0, 5, 5);

# Test 11: Custom bounds
statement ok
CREATE TABLE custom_range(x INT);

statement ok
INSERT INTO custom_range VALUES (50),(60),(70);

# Sum = 180, but clamped to [0, 100] => 50+60+70 clamped => 50+60+70 = 180, but each clamped first
# Actually: each value clamped individually: 50+60+70 => 50+60+70 = 180
# Wait, with upper=100, all values are within bounds, sum should be ~180
query I
SELECT (dp_sum(x, 1000000000000.0, 0, 100) BETWEEN 179.99 AND 180.01)::INT FROM custom_range;
----
1

# Cleanup
statement ok
DROP TABLE integers;

statement ok
DROP TABLE negative_vals;

statement ok
DROP TABLE large_vals;

statement ok
DROP TABLE mixed_types;

statement ok
DROP TABLE empty_table;

statement ok
DROP TABLE with_nulls;

statement ok
DROP TABLE departments;

statement ok
DROP TABLE custom_range;

